<!DOCTYPE html>

<html>

<head>
    <title>Змейка</title>
    <style>
        #canvas {
            border: 1px solid red;
            width: 1000;
            height: 700;
        }
    </style>
</head>

<body>
    <!--Тег "canvas" создает холст, который является контейнером для
    отображения графики в браузере. Нужно помнить, что свойства "width" и
    "height" у элемента "canvas", которые были указаны в HTML, не совпадают
    со свойствами "width" и "height", которые мы указываем в CSS.-->
    <canvas id='canvas' width='1000' height='700'></canvas>

    <script>
        /*Объект это один из типов данных в JS. Объект указывается в фигурных
        скобках "{}". Внутри объекта указываются свойства. У каждого свойства
        внутри объекта указывается значение при помощи двоеточия. Свойства в
        объекта перечислияются через запятую. При обращении к несущесвтующему 
        свойству объекта, будет возвращается undefined.*/

        /*Создаем специальный объект, который содержит в себе основную логику работы
        нашей игры.*/
        var game = {
            /*Тик это единица измерения времени, связанная с повторяющимеся действиями.
            В нашей игре каждый тик отображает единичное изменение изображения на экране.*/
            tickNumber: 0,
            /*Свойство "timer" нужно, чтобы сохранять в нем "setTimeout(), для возможности
            прекращения его работы в нужный нам момент при помощи метода "clearTimeout()".*/
            timer: null,
            /*Свойство "score" отвечает за количество набранных очков в ходе игры.*/
            score: 0,
            /*Массив это один из типов данных в JS. Массив указывается в квадратных 
            скобках "[]". Внутри массива указываются элементы массива через запятую.
            У каждого элемента массива есть свой индекс. Индексы начинают отсчет с 0.
            Чтобы обратиться к какому-то элементу в массиве, нужно указать имя массива и индекс
            нужного элемента в квадратных скобках.
            
            Создаем специальный массив, который образно изображает наше игровое поле для игры
            в змейку. Каждая решетка означает стену, а каждый пробел пустое место. Этот массив
            мы будем использовать дальше с методом "forEach()", чтобы отрисовать наше игровое поле
            на холсте в объекте "graphics" в его методе "drawBoard()".*/
            board: [
                '####################',
                '#                  #',
                '#                  #',
                '#                  #',
                '#                  #',
                '#                  #',
                '#      ##  ##      #',
                '#      ##  ##      #',
                '#                  #',
                '#                  #',
                '#                  #',
                '#                  #',
                '#                  #',
                '####################'
            ],
            /*Свойство "fruit" содержит координаты, по которой отрисовываются фрукты 
            в виде одного квадрата. Изначально отрисовывается только один фрукт, но это 
            свойство используется в коде, чтобы добавлять и новые фрукты.*/
            fruit: [
                { x: 3, y: 8 }
            ],
            /*Создаем метод "tick()", который занимается обработкой тиков в игре.*/
            tick: function () {
                /*Метод "clearTimeout()" прекращает работу какого-то указаного "setTimeout()".
                То есть, чтобы была возможность такой остановки, "setTimeout()" необходимо
                сохранять в переменную, иначе не будет возможности к нему обратиться.
                
                Когда игра начинается метод "game.tick()" запускается один раз благодаря
                "gameControl.startGame()". Если мы не будем очищать "setTimeout()", который
                в конце метода "game.tick()" вызывает еще один метод "game.tick()", и если
                мы не будем нажимать никаких клавиш, то мы не заметим ничего странного, то есть
                змейка будет двигаться каждые 300 милисекунд, как и надо по одной клетке. Так происходит 
                потому, что у нас будет создана одна бесконечная очередь, где один метод "setTimeout()" 
                вызывает другой метод "setTimeout()", и соответственно самый первый метод "setTimeout()" не 
                закончит свою работу, пока не закончат свою работу следующие методы "setTimeout()". Но если 
                мы нажмем какую-нибудь клавишу управления, то благодаря методу "gameControl.processInput()" 
                запустится еще одна бесконечная очередь из  методов "setTimeout()", то есть каждые 300 
                милисекунд будут запускаться два метода "game.tick()", что приведет к тому, что каждый тик 
                наша змейка уже будет ходить по 2 клетки. Для того, чтобы такого не было, мы при каждом новом 
                вызове метода "game.tick()" при помощи метода "clearTimeout()" прекращаем работу предыдущего 
                метода "setTimeout()", чтобы у нас не создавались бесконечные очереди из методов "setTimeout()".*/
                window.clearTimeout(game.timer);
                /*Увеличиваем количество тиков на 1.*/
                game.tickNumber++;

                /*Каждый тик мы проверяем делится ли нацело на 10 количество тиков, и если да,
                то создаем фрукт на игровом поле.*/
                if (game.tickNumber % 10 === 0) {
                    game.addRandomFruit();
                };

                /*Локальная переменная "result" нам нужна, чтобы определить столкнулись ли
                мы со стенкой или с самой змейкой, так как в этих случаях метод "snake.move()"
                вернет нам строку "gameover", что будет означать конец игры.*/
                var result = snake.move();

                if (result === "gameover") {
                    alert("Игра окончена! Очков набрано: " + game.score);
                    return;
                };

                /*Вызываем метод "graphics.drawGame()", чтобы полностью перерисовать нашу игру в
                актуальном состоянии.*/
                graphics.drawGame();

                /*Создаем "setTimeout()", который вызывает метод "game.tick()" каждые 300
                милисекунд. Тем самым метод "game.tick()" зацикливает сам себя до тех пор, пока
                мы не прекратим работу этого "setTimeout()".*/
                game.timer = window.setTimeout("game.tick()", 300);
            },
            /*Метод "addRandomFruit()" высчитывает координаты для фруктов.*/
            addRandomFruit: function () {
                /*Сначала вычисляем координату Y для фрукта.*/
                var randomY = Math.floor(Math.random() * game.board.length) + 0;
                /*Затем вычисляем координату X для фрукта.*/
                var randomX = Math.floor(Math.random() * game.board[randomY].length) + 0;
                /*Упаковываем полученные координаты в объект.*/
                var randomLocation = { x: randomX, y: randomY };

                /*Если на полученной координате нет стенки и нет фрукта, то мы добавляем
                полученную координату в объект, который хранит координаты всех фруктов в игре.*/
                if (game.isEmpty(randomLocation) && !game.isFruit(randomLocation)) {
                    game.fruit.push(randomLocation);
                };
            },
            /*Метод "isEmpty()" определяет является ли пустотой клетка по указанной координате.*/
            isEmpty: function (location) {
                /*У любой строки можно получить любой символ по индексу этого символа, так же как
                мы получаем элемент по индексу у массива.*/
                return game.board[location.y][location.x] === ' ';
            },
            /*Метод "isWall()" определяет является ли стеной клетка по указанной координате.*/
            isWall: function (location) {
                return game.board[location.y][location.x] === '#';
            },
            /*Метод "isFruit()" определяет является ли стеной клетка по указанной координате.*/
            isFruit: function (location) {
                /*Пробегаемся циклом по всем координатам наших фруктов и если клетка, на которую
                мы перешли имеет такие же координаты, как и один из фруктов, то мы удаляем координату
                этого фрукта из свойства "game.fruit" и возвращаем true, как знак того, что это был
                фрукт. Иначе вернем false, как знак того, что это был не фрукт.*/
                for (let fruitNumber = 0; fruitNumber < game.fruit.length; fruitNumber++) {
                    var fruit = game.fruit[fruitNumber];

                    if (location.x === fruit.x && location.y === fruit.y) {
                        /*Метод "splice()" изменяет содержимое массива, удаляя или заменяя 
                        существующие элементы и/или добавляя новые элементы на место. Первым параметром
                        указывается под каким индексом будут изменения. Вторым параметром указывается
                        сколько надо удалить элементов, начиная с указанного индекса. Третьим параметром
                        указывается какой элемент нужно добавить по указанному индексу.*/
                        game.fruit.splice(fruitNumber, 1);
                        return true;
                    };
                };

                return false;
            },
            /*Метод "isSnake()" определяет является ли змейкой клетка по указанной координате.*/
            isSnake: function (location) {
                /*Пробегаемся циклом по всем координатам наших частей змейки и если клетка, на которую
                мы перешли имеет такие же координаты, как и одна из частей змейки, то мы возвращаем true, 
                как знак того, что это была часть змейки. Иначе вернем false, как знак того, что это 
                не была часть змейки.*/
                for (let snakePart = 0; snakePart < snake.parts.length; snakePart++) {
                    var part = snake.parts[snakePart];

                    if (location.x === part.x && location.y === part.y) {
                        return true;
                    };
                };

                return false;
            }
        };

        /*Создаем специальный объект, который содержит в себе свойства и методы, описывающие
        поведение змейки.*/
        var snake = {
            /*Свойство "parts" содержит три координаты, по который отрисовывается змейка изначально
            в виде трех квадратов. Также это свойство используется в коде, чтобы добавлять новые
            квадраты для змейки и менять ее текущие координаты.*/
            parts: [
                { x: 4, y: 2 },
                { x: 3, y: 2 },
                { x: 2, y: 2 }
            ],
            /*Свойство "facing" указывает в каком направлении движется змейка в текущий момент.*/
            facing: "E",
            /*Метод "nextLocation()" определяет следущую координату головы змейки при ее
            движении.*/
            nextLocation: function () {
                /*Создаем три локальных переменных, которые хранят координату головы змейки,
                координату X и координату Y головы змейки.*/
                var snakeHead = snake.parts[0];
                var targetX = snakeHead.x;
                var targetY = snakeHead.y;

                /*Если направление движения змейки север, то уменьшаем координату Y головы,
                чтобы змейка двигалась вверх.*/
                targetY = snake.facing === "N" ? targetY - 1 : targetY;
                /*Если направление движения змейки юг, то увеличиваем координату Y головы,
                чтобы змейка двигалась вниз.*/
                targetY = snake.facing === "S" ? targetY + 1 : targetY;
                /*Если направление движения змейки запад, то уменьшаем координату X головы,
                чтобы змейка двигалась влево.*/
                targetX = snake.facing === "W" ? targetX - 1 : targetX;
                /*Если направление движения змейки восток, то увеличиваем координату X головы,
                чтобы змейка двигалась вправо.*/
                targetX = snake.facing === "E" ? targetX + 1 : targetX;

                /*В конце возвращаем новую координату для головы змейки.*/
                return { x: targetX, y: targetY };
            },
            /*Метод "move()" осуществляет передвижение змейки.*/
            move: function () {
                /*Получаем новую координату головы змейки, при ее движении.*/
                var location = snake.nextLocation();

                /*Проверяем является ли место, куда мы хотим сдвинуть нашу змейку стеной или
                самой змейкой. Если это так, то возвращаем строку "gameover", как знак проигрыша.*/
                if (game.isWall(location) || game.isSnake(location)) return "gameover";

                /*Проверяем является ли место, куда мы хотим сдвинуть нашу змейку пустотой. Если это так, 
                то мы добавляем новую координату к частям змейки, которая будет означать новую координату головы
                змейки. А затем удаляем координату хвоста змейки. Тем самым мы сдвигаем все нашу змейку, добавляя
                одну координату впереди и удаляя одну сзади.*/
                if (game.isEmpty(location)) {
                    /*Метод "unshift()" добавляет один или более элементов в начало массива и 
                    возвращает новую длину массива.*/
                    snake.parts.unshift(location);
                    /*Метод "pop()" удаляет последний элемент из массива и возвращает его 
                    значение.*/
                    snake.parts.pop();
                };

                /*Проверяем является ли место, куда мы хотим сдвинуть нашу змейку фруктом. Если это так, 
                то мы добавляем новую координату к частям змейки, которая будет означать новую координату головы
                змейки. А затем удаляем координату хвоста змейки. А затем увеличивать количество очков.*/
                if (game.isFruit(location)) {
                    snake.parts.unshift(location);
                    game.score++;
                };
            }
        };

        /*Создаем специальный объект, который включают в себя свойства и метода для работы
        с графикой.*/
        var graphics = {
            /*Сохраняем в свойстве "canvas" наш холст.*/
            canvas: document.getElementById('canvas'),
            /*Свойство "squareSize" определяет размер стороны квадратов, из которых мы отрисовываем
            всю нашу игру.*/
            squareSize: 50,
            /*Метод "drawBoard()" отрисовывает наше игровое поле. В качестве параметра он берет
            контекст рисования на нашем холсте.*/
            drawBoard: function (ctx) {
                /*Создаем переменную для отслеживания позиции последнего добавленного квадрата
                по оси Y. Эта координата меняется только тогда, когда мы переходим на новую строку отрисовки
                квадратов нашего игрового поля. Для этого мы ее указали на уровень выше всех следующих двух
                методов "forEach()", иначе они бы сбрасывали эту переменную на 0 каждый раз, когда брали бы новый
                элемент массива для обработки.*/
                var currentYoffset = 0;

                /*У каждого массива есть метод "forEach()". Этот метод принимает один
                параметр в виде callback-функции. В свою очередь эта callback-функция может
                иметь до 3-х параметров. Первый параметр является обязательным, который
                является текущим элементом массива. Второй параметр является индексом 
                текущего элемента массива. Третий параметр является всем нащим массивом.
                Метод "forEach()" вызывает переданную callback-функцию поочередно с каждым
                элементом массива.*/
                game.board.forEach(function (line) {
                    /*У каждой строки есть метод "split()". Этот метод разбивает строку
                    на компоненты, то есть он превращает строку в массив. Этот метод использует
                    один параметр, который определяет разделитель. Этот метод начнет поиск указанного
                    разделителя с левого конца строки. Как только он найдет первый такой разделитель, то
                    все, что было до этого первого разделителя, станет первым элементом массива. Потом
                    этот метод продолжит поиск следующего разделителя в строке. Как только он найдет
                    следующий разделитель, то все что, было между первым и вторым разделителями, станет
                    вторым элементом массива. И так до конца всей строки.
                    
                    Берем первый элемент массива, который является строкой. Превращаем эту
                    строку в массив, где каждый элемент является каждым символом строки. То есть
                    из этого '####################' мы получим 
                    ["#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#"].
                    Когда первый элемент будет отработан, то возьмется второй элемент, то есть
                    '#                  #', который в свою очередь тоже будет превращен массив. И так до
                    конца всего массива.
                    */
                    line = line.split('');

                    /*Создаем переменную для отслеживания позиции последнего добавленного квадрата
                    по оси X. Эта координата меняется только тогда, когда мы отрисовали один квадрат.
                    Для этого мы ее указали на уровень выше следующего одного метода "forEach()", иначе 
                    он бы сбрасывал эту переменную на 0 каждый раз, когда брал бы новый элемент массива для 
                    обработки. 
                    Но мы сбрасываем эту координату на 0 каждый раз когда переходим к отрисовке следующей 
                    строки квадратов. А переход от одной строки к другой происходит именно в первом методе "forEach()",
                    поэтому мы и указали эту переменную в нем.*/
                    var currentXoffset = 0;

                    /*Далее берем полученный массив и вызываем уже для него метод "forEach()".*/
                    line.forEach(function (character) {
                        /*Если текущий элемент массива является "#", то мы закращиываем прямоугольную
                        область черным цветом. Первый квадрат, который мы зарисуем будет рисоваться
                        из координат (0; 0).*/
                        if (character === '#') {
                            /*Свойство "fillStyle" используется в контексте рисования нашего холста.
                            Это свойство позволяет указать цвет заливки холста. То есть это почти
                            как указать какой цвет краски взять в данный момент.*/
                            ctx.fillStyle = 'black';
                            /*Метод "fillRect()" используется в контексте рисования нашего холста.
                            Этот метод получает 4 параметра. Этот метод зарисовывает прямоугольную
                            площадь на холсте. Первые два параметра это начальные координаты X и Y
                            такой прямоугольной площади, то есть его верхняя левая точка. А вторые два
                            параметра указывают ширину и высоту этой прямоугольной площади.*/
                            ctx.fillRect(currentXoffset, currentYoffset, graphics.squareSize, graphics.squareSize);
                        } else {
                            ctx.fillStyle = 'lightblue';
                            ctx.fillRect(currentXoffset, currentYoffset, graphics.squareSize, graphics.squareSize);
                        };

                        /*Когда нарисуем квадрат стены или пропуск, то увеличиваем координату X на длину нарисованного
                        квадрата, чтобы следющий квадрат уже отрисовывался от координаты (50; 0). Таким образом
                        этот метод "forEach()" отрисует всю линию игрового поля.*/
                        currentXoffset += graphics.squareSize;
                    });

                    /*После того, как отрисуем первую линию стенки, мы увеличиваем координату Y, относительно
                    которой дальше будут отрисовываться следущие квадраты нашего игрового поля. То есть для первой
                    стенки координаты для отрисовки квадратов были (0; 0), (50; 0), (100; 0) и так далее, а для
                    второй уже будут (0; 50), (50; 50), (100; 50) и так далее.*/
                    currentYoffset += graphics.squareSize;
                });
            },
            /*Метод "draw()" нужен, чтобы получить данные о каком-то объекте игры и отрисовать его по этим
            данным. Первым параметром этот метод принимает контекст холста, вторым - массив с координатами
            объекта, третьим - цвет этого объекта, четвертым - булево значение, которое указывает является
            ли объект для отрисовки змейкой.*/
            draw: function (ctx, source, color, isSnake) {
                /*Вызываем для массива с координатами метод "forEach()".*/
                source.forEach(function (part, index) {
                    /*Создаем локуальную переменную, которая в итоге будет хранить цвет зарисовки.*/
                    let tempColor;

                    /*Проверяем является ли то, что мы хотим отрисовать в данный момент головой змейки.
                    Если это так, то устанавливаем специальный цвет, иначе используем тот цвет, который
                    был передан в метод.*/
                    if (index === 0 && isSnake) {
                        tempColor = "darkgreen";
                    } else {
                        tempColor = color;
                    };

                    /*Определяем координаты в пикселях, где будет осуществлять отрисовку.*/
                    var partXlocation = part.x * graphics.squareSize;
                    var partYlocation = part.y * graphics.squareSize;

                    /*Непосредственно осуществляем отрисовку.*/
                    ctx.fillStyle = tempColor;
                    ctx.fillRect(partXlocation, partYlocation, graphics.squareSize, graphics.squareSize);
                });
            },
            /*Метод "drawGame()" нужен для, того отрисовывать всю игру каждый новый тик с
            актуальными данными.*/
            drawGame: function () {
                /*Метод "getContext()" создает нужный контекст рисования внутри контейнера 
                "canvas".*/
                var ctx = graphics.canvas.getContext("2d");
                /*Метод "clearRect()" используется в контексте рисования нашего холста.
                Этот метод получает 4 параметра. Этот метод затирает прямоугольную
                площадь на холсте. Первые два параметра это начальные координаты X и Y
                такой прямоугольной площади, то есть его верхняя левая точка. А вторые два
                параметра указывают ширину и высоту этой прямоугольной площади.
                
                Этот код очищает весь наш холст. Но в нашем случае эта строчка не является
                обязательной, так как метод "graphics.drawBoard()" постоянно перекрашивает каждый тик
                все пустые клетки голубым цветом, тем самым затирая след змейки.*/
                ctx.clearRect(0, 0, graphics.canvas.width, graphics.canvas.height);

                /*После того как очистили весь экран, то отрисовываем заново игровое поле,
                фрукты и змейку с актуальными координатами. Здесь мы специально отрисовываем
                сначала фрукты, затем змейку, чтобы не отрисовать фрукт поверх змейки.*/
                graphics.drawBoard(ctx);
                graphics.draw(ctx, game.fruit, "red", false);
                graphics.draw(ctx, snake.parts, "green", true);
            }
        };

        /*Создаем специальный объект, который включают в себя свойства и метода для реализации
        управления змейкой.*/
        var gameControl = {
            /*Метод "processInput()" отвечает за обработку нажатых клавиш с целью
            управления змейкой. Поскольку этот метод вызывается обработчиком событий, то
            первым параметром он получает объект события, связанный с какой-то нажатой
            клавишей.*/
            processInput: function (keyPressed) {
                /*Сначала обращаемся к нашему объекту события какой-то нажатой клавиши.
                У этого объекта берем свойство "key", в котором строковое значение нажатой
                клавиши. Потом у этого строкового значения вызываем метод "toLowerCase()",
                чтобы привести это строковое значение к нижнему регистру. Это нам нужно, так
                как далее мы обрабатываем строковые значения только в маленьком регистре.
                И в конце мы указываем, что это свойство "key" получает новое значение в 
                виде преобразованного строкого значения.*/
                var key = keyPressed.key.toLowerCase();

                /*Далее создаем локальную переменную, которая получает текущее значение в
                какую сторону смотрит змейка.*/
                var targetDirection = snake.facing;

                /*Если нажата клавиша "w" и текущее направление движения змейки это не юг, 
                то формируем новое направление змейки в виде севера.*/
                if (key === "w" && snake.facing !== "S") {
                    targetDirection = "N";

                    /*И запускаем следующий тик игры, для того, чтобы игрок мог зажать или 
                    нажимать клавиши управления чаще с целью увеличить скороть змейки, так 
                    как тики будут происходить чаще чем 1 раз в 300 милисекунд.*/
                    game.tick();
                };
                /*Если нажата клавиша "a" и текущее направление движения змейки это не восток, 
                то формируем новое направление змейки в виде запада.*/
                if (key === "a" && snake.facing !== "E") {
                    targetDirection = "W";

                    game.tick();
                };
                /*Если нажата клавиша "s" и текущее направление движения змейки это не север, 
                то формируем новое направление змейки в виде юга.*/
                if (key === "s" && snake.facing !== "N") {
                    targetDirection = "S";

                    game.tick();
                };
                /*Если нажата клавиша "d" и текущее направление движения змейки это не запад, 
                то формируем новое направление змейки в виде востока.*/
                if (key === "d" && snake.facing !== "W") {
                    targetDirection = "E";

                    game.tick();
                };

                /*Далее указываем новое текущее направление змейки.*/
                snake.facing = targetDirection;                
            },
            /*Создаем метод "startGame()", который должен запускать нашу игру.*/
            startGame: function () {
                /*Метод "addEventListener()" регистрирует определенный обработчик события, вызванного на
                любом указанном элементе. Этот метод будет вызывать указанную вторым параметром callback-функцию,
                каждый раз, когда срабатывает указанное событие в первом параметре.

                Каждый раз, когда срабатывает какое-то событие, формируется специальный объект события.
                И этот объект автоматически отправляется первым параметром в callback-функцию, которая
                вызывается методом "addEventListener()".
                
                Здесь мы остлеживаем событие по нажатию клавиш клавиатуры. При каждом таком событии
                будет вызываться метод "gameControl.processInput()", который отвечает за обработку
                нажатых клавиш.*/
                window.addEventListener("keypress", gameControl.processInput, false);

                /*Запускаем первый тик нашей игры, чтобы змейка начала двигаться сама.*/
                game.tick();
            }
        };

        /*При запуске файла начинаем игру.*/
        gameControl.startGame();
    </script>
</body>

<footer></footer>

</html>