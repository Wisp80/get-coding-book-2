/*-------------------------------------------------------------------------------------------------------------*/
var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');

/*Функция-конструктор позволяет создавать однотипные объекты на основе свойств и методов, указанных в самой
этой функции. Название таких функции пишется с большой буквы и в виде существительного. Для описания свойств
и методов, которые должны быть переданы в объект, который будет создан на основе функции-конструктора, они
должны быть указаны при помощи ключевого слова 'this'.
Данная функция-конструктор нужна для создания объектов, которые будут обозначать ракетки для игры в теннис.*/
function Paddle(x, y, width, height) {
    /*Значения 'x' и 'y' обозначают начальные координаты ракетки по X и по Y соответственно. 
    Значения 'width' и 'height' обозначают ширину и высоту ракетки соответственно. 
    Значение 'speedModifier' обозначает множитель скорости полета мячика при ударе о ракетку, изначально 
    равен нулю.*/
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.speedModifier = 0;

    /*Метод 'hasCollidedWith()' проверяет была столкнулся ли мячик с какой-то из ракеток. В качестве
    аргумента принимает объект, связанный с мячиком.*/
    this.hasCollidedWith = function (ball) {
        /*Создаем 2 локальные переменные, которые хранят текущие координаты X и Y ракетки.*/
        var paddleLeftWall = this.x;
        var paddleTopWall = this.y;
        /*Создаем локальную переменную, которая хранит сумму длины от левой стороны экрана до текущей координаты X 
        ракетки и длины ракетки по X.*/
        var paddleRightWall = this.x + this.width;
        /*Создаем локальную переменную, которая хранит сумму длины от верха экрана до текущей координаты Y ракетки 
        и длины ракетки по Y.*/
        var paddleBottomWall = this.y + this.height;

        /*Далее проверяем получилось так, что мячик оказался внутри ракетки. Если да, то возвращаем true, что
        будет означать, что была коллизия мяча с ракеткой.*/
        if (
            ball.x > paddleLeftWall
            && ball.x < paddleRightWall
            && ball.y > paddleTopWall
            && ball.y < paddleBottomWall
        ) {
            return true;
        };

        /*Если предыдущая проверка показала, что колизии не было, то возвращаем false.*/
        return false;
    };

    /*Метод 'move()' нужен для того, что бы игрок и ai смогли управлять ракетками. Этот метод принимает один 
    аргумент, который обозначает код нажатой клавиши, к примеру 38 - стрелка вверх, 40 - стрелка вниз.*/
    this.move = function (keyCode) {
        /*Создаем локальную переменную 'nextY', задача которой сформировать следующую координату Y ракетки.
        Изначально равно текущему значению координаты ракетки по оси Y.*/
        var nextY = this.y;

        /*Далее с помощью 'if', проверяем нажал ли игрок стрелку вниз. Если да, то прибавляем 5 пикселей к текущей 
        координате по оси y и задаем значение свойства 'speedModifier' равное 1.5. Аналогично и со стрелкой вниз, 
        только прибавляем к y-координате не 5, а -5, чтобы ракетка двигалась в противоположном направлении. Так 
        же пишем еще один 'else', для того чтобы сбрасывать значение у 'speedModifier' на изначальное, если игрок 
        нажимает любую кнопку, кроме вверх/вниз.*/
        if (keyCode == 40) {
            nextY += 5;
            this.speedModifier = 1.5;
        } else if (keyCode == 38) {
            nextY += -5;
            this.speedModifier = 1.5;
        } else { // to remove or rewrite
            this.speedModifier = 0;
        };

        /*Затем проверяем, с помощью тернарных выражений, больше ли нуля вычисляемая следующая координата Y ракетки.
        Если это так, то делаем, чтобы следующая координата Y ракетки была равна нулю. Эту проверку мы делаем, чтобы
        ракетка не могла уйти за верхнюю сторону экрана.*/
        nextY = nextY < 0 ? 0 : nextY;

        /*Далее проверяем, с помощью тернарных выражений, является ли сумма длины от верха экрана до вычисляемой 
        следующей координаты Y ракетки и длины ракетки по Y больше длины нашего экрана. Если это так, то следущая 
        координата Y ракетки высчитывается так, чтобы на экране оставалось минимально необходимое расстояние по Y, 
        чтобы вместить ракетку. Таким образом мы делаем, чтобы ракетка не вылезала за нижнюю сторону экрана.*/
        nextY = nextY + this.height > 480 ? 480 - this.height : nextY;

        /*После всех вычислений устанавливаем новую текущую координату ракетки по Y.*/
        this.y = nextY;
    };
};

/*При помощи ключевого слова 'new' и нашей функции-конструктора 'Paddle' создаем два объекта, которые
обозначают ракетку игрока и ракетку AI.*/
var player = new Paddle(5, 200, 25, 100);
var ai = new Paddle(610, 200, 25, 100);

/*Создаем объект, обозначающий мячик.*/
var ball = {
    /*Свойства 'x' и 'y' обозначают начальные координаты мячика по X и по Y соответственно.
    Свойство 'radius' обозначает радиус мячика.
    Свойства 'xSpeed' и 'ySpeed' обозначают скорость мячика по X и по Y соответственно.*/
    x: 320, y: 240, radius: 3, xSpeed: 6, ySpeed: 0,

    /*Метод 'reverseX' инвертирует скорость мячика по X.*/
    reverseX: function () {
        this.xSpeed *= -1;
    },

    /*Метод 'reverseY' инвертирует скорость мячика по Y.*/
    reverseY: function () {
        this.ySpeed *= -1;
    },

    /*Метод 'reset' сбрасывает характеристики мячика на начальное значение.*/
    reset: function () {
        this.x = 320;
        this.y = 240;
        this.xSpeed = 6;
        this.ySpeed = 0;
    },

    /*Метод 'isBouncing' проверяет отскакивает ли мячик в данный момент.*/ // to remove
    isBouncing: function () {
        return ball.ySpeed != 0;
    },

    /*Метод 'modifyXSpeedBy' изменяет скорость мячика по X. Этот метод принимает один аргумент,
    который обозначает модификатор скорости мячика по X.*/
    modifyXSpeedBy: function (modification) {
        /*Если наш мячик двигается влево, то это означает, что его скорость идет со знаком минус,
        так как, чтобы реализовать движение в левую сторону по оси X надо уменьшать координату X
        мячика. И если же мячик в данный момент времени движется влево, то чтобы увеличить его скорость
        нужно прибавить модификатор скорость со знаком минус, чтобы отрицательная скорость сложилась
        с модификатором, а не вычлась. Иначе ничего не делаем с модификатором, чтобы сложить его с
        положительной скоростью мячика при движении вправо.*/
        modification = this.xSpeed < 0 ? modification * -1 : modification;
        /*Высчитываем скорость мячика, увеличивая ее на модификатор.*/
        var nextValue = this.xSpeed + modification;

        /*При помощи метода 'Math.abs()' получаем модуль высчитываемой скорости, и если этот модуль
        больше 9, то делаем так, чтобы наша скорость была равна 9 и не больше этого. Нам это нужно,
        чтобы мячик не проходил сквозь ракетки.*/
        nextValue = Math.abs(nextValue) > 9 ? 9 : nextValue;

        /*У нас может быть такой случай, когда мячик отскакивает от вражеской ракетки и высчитываемая
        скорость мячика по X, как меньшая -9. В таком случае предыдущая строка кода, сделает так, что 
        скорость мячика по X будет 9, то есть мячик полетить дальше вправо сквозь ракетку врага. Чтобы 
        избежать такого мы делаем специальную проверку.*/
        if (modification < 0 && nextValue > 0) {
            nextValue *= -1;
        };

        /*И в конце указываем новую текущую скорость мячки по X.*/
        this.xSpeed = nextValue;
    },

    /*Метод 'modifyYSpeedBy' изменяет скорость мячика по Y. Этот метод принимает один аргумент,
    который обозначает модификатор скорости мячика по Y.*/
    modifyYSpeedBy: function (modification) {
        /*Если наш мячик двигается вверх, то это означает, что его скорость идет со знаком минус,
        так как, чтобы реализовать движение вверх по оси Y надо уменьшать координату Y мячика. И 
        если же мячик в данный момент времени движется вверх, то чтобы увеличить его скорость
        нужно прибавить модификатор скорость со знаком минус, чтобы отрицательная скорость сложилась
        с модификатором, а не вычлась. Иначе ничего не делаем с модификатором, чтобы сложить его с
        положительной скоростью мячика при движении вниз.*/
        modification = this.ySpeed < 0 ? modification * -1 : modification;

        /*И в конце указываем новую текущую скорость мячки по Y.*/
        this.ySpeed += modification;
    }
};

/*Функция 'updateGame()' подготавливает данные для отрисовки следующего кадра игры.*/
function updateGame() {
    /*Сдвигаем координаты мячика, чтобы в следующем кадре он сдвинулся.*/
    ball.x += ball.xSpeed;
    ball.y += ball.ySpeed;

    /*Если мячик улетел за левую или за правую границы экрана, то мы сбрасываем характеристики мячика,
    чтобы начать игру заново.*/
    if (ball.x < 0 || ball.x > 640) {
        ball.reset();
    };

    /*Если мячик касается верхней или нижней границ экрана, то мы сбрасываем инвертируем координату Y
    мячика, чтобы заставить мячик отскочить от стенки.*/
    if (ball.y <= 0 || ball.y >= 480) {
        ball.reverseY();
    };

    /*Узнаем столкнется ли мячик с ракеткой игрока или врага в будущем кадре игры.*/
    var collidedWithPlayer = player.hasCollidedWith(ball);
    var collidedWithAi = ai.hasCollidedWith(ball);

    /*Если в следующем кадре мячик сталкивается с какой-то из ракеток, то инвертируем направление по X
    мячика, увеличиваем скорость мячика по X, высчитываем на сколько мы хотим увеличить скорость
    мячика по Y, увеличиваем скорость мячика по Y.*/
    if (collidedWithPlayer || collidedWithAi) {
        ball.reverseX();
        ball.modifyXSpeedBy(0.25);
        var speedUpValue = collidedWithPlayer ? player.speedModifier : ai.speedModifier; // to rewrite
        ball.modifyYSpeedBy(speedUpValue);
    };    

    /*Конструкция 'for .. in' работает схожим образом как и 'for', только эта конструкция предназначена
    для свойств объекта. Здесь мы пробегаем по списку нажатых клавиш в данный момент и для каждой из них
    вызывает метод 'move()' у игрока, чтобы осуществить движение его ракетки вверх или вниз.*/
    for (var keyCode in heldDown) {
        player.move(keyCode);
    };

    /*Высчитываем координату по Y, которая обозначает середину ракетки врага в данный момент.*/
    var aiMiddle = ai.y + (ai.height / 2);

    /*Если центр ракетки врага находится выше мячика, то сдвигаем ракетку противника вниз.*/
    if (aiMiddle < ball.y) {
        ai.move(40);
    };

    /*Если центр ракетки врага находится ниже мячика, то сдвигаем ракетку противника вверх.*/
    if (aiMiddle > ball.y) {
        ai.move(38);
    };
};

/*Создаем специальный объект, который используется для хранения данных, описывающих
какие в данный момент клавиши нажаты.*/
var heldDown = {};

/*Подписываем две callback-функции на события нажатия и отпуска любой клавиши клавиатуры. В
первой функции происходит создание нового свойства, имя для которого будет браться из кода
нажатой клавиши, а значение будет равно 'true'. При таком способе задания свойств объекту важно
указывать в квадратных скобках именно строку. А во второй функции мы удаляем при помощи ключевого
слова 'delete' это свойство из указанного объекта.*/
window.addEventListener('keydown', function () { heldDown[event.keyCode] = true; console.log(heldDown); }, false);
window.addEventListener('keyup', function () { delete heldDown[event.keyCode]; console.log(heldDown); }, false);

/*Функция 'renderPaddle()' отрисовывает ракетки.*/
function renderPaddle(paddle) {
    ctx.fillStyle = 'white';
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
};

/*Функция 'renderBall()' отрисовывает мячик.*/
function renderBall(ball) {
    /*Метод 'beginPath()' начинает контур или сбрасывает текущий контур, то есть он как-бдуто позволяет нам
    симитировать момент когда мы держим, например, карандаш в руке и прикладываем его к бумаге, чтобы начать
    рисовать, и момент когда мы убираем карандаш от бумаги, чтобы взять, например, другой карандаш и начать
    рисовать что-то другое. Важно понимать, что при каждом таком сбросе, место откуда мы будем начинать рисовать
    это координаты (0;0).*/
    ctx.beginPath();
    /*Метод "arc()" создает дугу/кривую (используется для создания окружностей или их части). Первыми двумя
    параметрами принимает координаты, где нужно отрисовать дугу или кривую. Третьим параметром принимает радиус
    круга. Четвертым и пятым параметрами принимает начальный и конечный углы. Чтобы создать круг при помощи этого 
    метода, нужно установить начальный угол в "0", а конечный угол в "2 * Math.PI". Последний параметр необязательный,
    он определяет, как рисовать окружность, по часовой стрелке или против часовой стрелки. По умолчанию установлено 
    значение false, что означает по часовой стрелке. Значение true указывает направление против часовой стрелки.*/
    ctx.arc(ball.x, ball.y, ball.radius, 0, 2 * Math.PI, false);
    ctx.fillStyle = 'white';
    ctx.fill();    
};

/*Функция "draw()" это большая функция, которая осуществляет отрисовку всего кадра игры.*/
function draw() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, 640, 480);
    renderPaddle(player);
    renderPaddle(ai);
    renderBall(ball);
};

/*Создаем функцию "tick()", который занимается обработкой тиков в игре.*/
function tick() {
    updateGame();
    draw();
    window.setTimeout('tick()', 1000 / 60);
};

tick();