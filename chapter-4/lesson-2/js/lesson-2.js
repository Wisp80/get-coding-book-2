let canvas = document.getElementsByClassName('canvas')[0];
let ctx = canvas.getContext('2d');

/*----------------------------------------------------------------------------------------------------------------------------------*/

/*Функция-конструктор для создания тайлов плиток.*/
function floor(x, height) {
    this.x = x; /*Координата X для создания прямоугольного тайла.*/
    this.width = canvas.width + 60; /*Ширина прямоугольного тайла.*/
    this.height = height; /*Высота прямоугольного тайла.*/
};

/*Объект, содержащий данные о мире.*/
const world = {
    height: canvas.height, /*Высота игрового мира.*/
    width: canvas.width, /*Ширина игрового мира.*/
    gravity: 10, /*Гравитация.*/
    highestFloor: canvas.height / 2, /*Максимально возможная высота какого-либо тайла.*/
    speed: 5, /*Скорость прокрутки мира.*/
    distanceTravelled: 0, /*Пройденное расстояние.*/
    maxSpeed: 15, /*Максимально возможная скорость прокрутки мира.*/
    tilesPassed: 0, /*Количество пройденных тайлов.*/
    autoScroll: true, /*Флаг, обозначающий прокрутку мира.*/

    /*Массив, содержащий объекты с данными о тайлах. Изначально всегда создается один тайл высотой в 140 пикселей
    слева на экране.*/
    floorTiles: [
        new floor(0, 140)
    ],

    /*Метод для остановки прокрутки мира.*/
    stop: function () {
        this.autoScroll = false;
    },

    /*Метод, подготовливающий данные по координатам X тайлов для следующего кадра, чтобы достигнуть прокрутку мира.*/
    moveFloor: function () {
        for (const i in this.floorTiles) {
            let tile = this.floorTiles[i]; /*Берем данные о каком-то тайле.*/
            tile.x -= this.speed; /*Сдвигаем координату X выбранного тайла влево.*/
            this.distanceTravelled += this.speed; /*Обновляем пройденное расстояние.*/
        };
    },

    /*Метод для генерации данных для будующих тайлов.*/
    addFutureTiles: function () {
        if (this.floorTiles.length >= 3) { /*Если уже есть данные для минимум трех тайлов, то ничего не делаем.*/
            return;
        };

        let previousTile = this.floorTiles[this.floorTiles.length - 1]; /*Получаем данные о самом последнем тайле.*/

        let biggestJumpableHeight = previousTile.height + player.height * 3; /*Определяем на какую максимальную
        высоту может запрыгнуть игрок.*/

        /*Если так получилось, что максимальная высота, на которую может запрыгнуть игрок оказалась больше, чем
        предустановленное ограничение на максимальную высоту тайла, то мы делаем так, чтобы максимальная высота,
        на которую может запрыгнуть игрок равна этому ограничению, чтобы случайно не создать тайл, на который
        не будет возможности запрыгнуть.*/
        if (biggestJumpableHeight > this.highestFloor) {
            biggestJumpableHeight = this.highestFloor;
        };

        let randomHeight = Math.floor(Math.random() * biggestJumpableHeight) + player.height; /*Генерируем случайную высоту для
        следующего тайла.*/

        let leftValue = previousTile.x + previousTile.width; /*Высчитываем координату X следующего тайла, то есть там, где
        кончается предыдущий тайл.*/

        let next = new floor(leftValue, randomHeight); /*Создаем данные для следующего тайла.*/
        this.floorTiles.push(next); /*Отправляем созданные данные в массив тайлов.*/
    },

    /*Метод для удаления тайлов, которых больше не видно на экране.*/
    cleanOldTiles: function () {
        for (const i in this.floorTiles) {
            /*Мы не видим какой-либо тайл, если он полностью ушел за экран, то есть на 700 пикселей влево от 0. Это
            значит, что его координата X как минимум равна -700.*/
            if (this.floorTiles[i].x <= -this.floorTiles[i].width) {
                this.floorTiles.splice(i, 1); /*Удаляем выбранный тайл из массива с данными по тайлам.*/
                this.tilesPassed++; /*Обновляем количество пройденных тайлов.*/

                if (this.tilesPassed % 3 === 0 && this.speed < this.maxSpeed) { /*Увеличиваем скорость прокрутки мира
                каждые 3 пройденных тайла.*/
                    this.speed++;
                };
            };
        };
    },

    /*Метод для определения какой тайл находится под правым углом игрока и какая у него высота. В качестве параметра 
    принимает координату X игрока.*/
    getDistanceToFloor: function (playerX) {
        for (const i in this.floorTiles) {
            let tile = this.floorTiles[i]; /*Берем данные о каком-то тайле.*/

            // if (this.floorTiles.length > 2 && i < 2 && playerX === player.x) {
            //     if (tile.x <= playerX &&
            //         tile.x + tile.width > playerX &&
            //         tile.x + tile.width < playerX + player.width &&
            //         tile.height <= this.floorTiles[Number(i) + 1].height) {
            //         // console.log(this.floorTiles[Number(i) + 1]);
            //         // alert('123');

            //         return this.floorTiles[Number(i) + 1].height;
            //     };
            // };

            /*Проверяем, что координата X выбранного тайла меньше, то есть левее, чем координата X персонажа или равна ей. 
            То есть проверяем, что игрок находится над этим тайлом. И также проверяем, что оставшийся участок выбранного
            тайла на экране не меньше, чем расстояние от левого конца экрана до координаты X игрока. Если оба условия верны, то
            есть игрок находится над выбранным тайлом, тогда возвращаем высоту этого тайла.*/
            if (tile.x <= playerX && tile.x + tile.width >= playerX) {
                return tile.height;
            };
        };

        return -1; /*???*/
    },

    /*Общий метод, подготавливающий данные по всему игровому миру для следующего кадра.*/
    tick: function () {
        if (!this.autoScroll) { /*Если прокрутка мира отключена, то ничего не делаем.*/
            return;
        };

        this.cleanOldTiles(); /*Удаляем тайлы, которых больше не видно на экране.*/
        this.addFutureTiles(); /*Генерируем данные для будующих тайлов.*/
        this.moveFloor(); /*Подготовливаем данные по координатам X тайлов для следующего кадра.*/
    },

    /*Метод для отрисовки игрового мира.*/
    draw: function () {
        /*Затираем весь экран.*/
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, this.width, this.height);

        for (const i in this.floorTiles) {
            let tile = this.floorTiles[i]; /*Берем данные о каком-то тайле.*/
            let y = world.height - tile.height; /*Вычисляем координату Y для отрисовки выбранного тайла.*/

            ctx.fillStyle = 'blue';
            ctx.fillRect(tile.x, y, tile.width, tile.height); /*Отрисовываем выбранный тайл.*/
        };

        ctx.fillStyle = 'white';
        ctx.font = '28px Arial';
        ctx.fillText('Скорость: ' + this.speed, 10, 40); /*Выводим текст о текущей скорости прокрутки мира.*/
        ctx.fillText('Пройдено: ' + this.distanceTravelled, 10, 75); /*Выводим текст о том, какое расстояние было пройдено.*/
    }
};

/*----------------------------------------------------------------------------------------------------------------------------------*/

/*Объект, содержащий данные об игроке.*/
const player = {
    x: 160, /*Координата X игрока.*/
    y: 320, /*Координата Y игрока.*/
    height: 20, /*Высота игрока.*/
    width: 20, /*Ширина игрока.*/
    downwardForce: world.gravity, /*Сила с которой игрок падает или прыгает.*/
    jumpHeight: 0, /*Параметр, который указывает на какой расстояние прыгнул игрок.*/

    /*Метод для определения расстояния от координаты Y игрока до тайла, над которым находится игрок.*/
    getDistanceFor: function (x) {
        let platformBelow = world.getDistanceToFloor(x); /*Определяем высоту тайла, который находится под правым углом игрока.*/

        return world.height - this.y - platformBelow;
    },

    /*Метод, который останавливает прокрутку мира, если игрок провалился в тайл, над которым находится, или врезался в следующий тайл,
    который выше игрока.*/
    applyGravity: function () {
        let currentDistanceAboveGround = this.getDistanceFor(this.x); /*Определяем расстояние от координаты Y игрока до тайла, над 
        которым находится игрок.*/

        /*Здесь в качестве параметра отдаем координату X игрока его правой стороны, чтобы проверять при помощи метода 
        "getDistanceFor()" не задевает ли игрок следующий тайл, и если это так, то возвращаем расстояние от координаты Y игрока 
        до этого следующего тайла. Если будет возвращено отрицательное число, то это будет значит, что следующий тайл выше игрока
        и игрок его уже задел своей правой стороной, то еcть он в него врезался.*/
        let rightHandSideDistance = this.getDistanceFor(this.x + this.width);

        console.log('A ' + currentDistanceAboveGround);
        console.log('B ' + rightHandSideDistance);

        /*Если игрок оказался ниже координаты Y тайла, над которым он находится, или игрок врезался в следующий тайл, который выше
        игрока, то останавливаем прокрутку мира.*/
        if (currentDistanceAboveGround < 20 || rightHandSideDistance < 20) {
            world.stop();
        };
    },

    /*Метод для обработки падения или прыжка игрока, а также колизии с тайлом, над которым находится игрок.*/
    processGravity: function () {
        this.y += this.downwardForce; /*Увеличивем координату Y игрока на силу тяжести, то есть опускаем его ниже. Если будет
        указываться отрицательное значение, то значит будем наоборот уменьшать координату Y игроку, то есть будем поднимать его
        вверх, что можно использовать для имитации прыжка.*/

        let floorHeight = world.getDistanceToFloor(this.x); /*Определяем высоту тайла, который находится под правым углом игрока.*/
        let topYofPlatform = world.height - floorHeight; /*Получаем координату Y тайла, который находится под правым углом игрока.*/

        /*Если координата Y нижней части игрока больше координаты Y тайла, над которым находится игрок, то мы делаем так, чтобы 
        координата Y игрока была на одну высоту игрока выше этого тайла, чтобы игрок не проваливался вниз экрана сквозь тайл, 
        Таким образом здесь мы создаем колизию игрока с тайлом, над которым он находится.*/
        if (this.y + this.height > topYofPlatform) {
            this.y = topYofPlatform - this.height;
        };

        if (this.downwardForce < 0) { /*Если игрок прыгнул, то делаем его падение.*/
            this.jumpHeight += (this.downwardForce * -1); /*Узнаем расстояние, на которое прыгнул игрок.*/

            if (this.jumpHeight >= player.height * 6) { /*Если игрок прыгнул в 6 раз выше себя самого, то мы меняем силу падения
            на положительную и сбрасываем параметр, который указывает на какой расстояние прыгнул игрок.*/
                this.downwardForce = world.gravity;
                this.jumpHeight = 0;
            };
        };
    },

    /*Метод, который заставляет прыгать нашего игрока.*/
    keyPress: function () {
        let floorHeight = world.getDistanceToFloor(this.x); /*Определяем высоту тайла, который находится под правым углом игрока.*/

        let onTheFloor = floorHeight === (world.height - this.y - this.height); /*Определяем касается ли игрок тайла, над которым он
        находится.*/

        if (onTheFloor) { /*Если игрок касается тайла, над которым находится, то заставлем подпрыгнуть игрока.*/
            this.downwardForce = -8;
        };
    },

    /*Общий метод, подготавливающий данные по игроку для следующего кадра.*/
    tick: function () {
        this.applyGravity(); /*Проверяем не провалился ли игрок в тайл, над которым находится, или не врезался ли в следующий тайл,
        который выше игрока. Если что-то из этого произошло, то останавливаем прокрутку экрана.*/
        this.processGravity(); /*Обрабатываем падение или прыжок игрока, а также колизию с тайлом, над которым находится игрок.*/
    },

    /*Метод для отрисовки игрока.*/
    draw: function () {
        ctx.fillStyle = 'green';
        ctx.fillRect(player.x, player.y, this.height, this.width)
    }
};

/*----------------------------------------------------------------------------------------------------------------------------------*/

window.addEventListener('keypress', function () { player.keyPress(); }, false);

function tick() {
    player.tick(); /*Подготавлием данные по игроку для следующего кадра.*/
    world.tick(); /*Подготавлием данные по игровому миру для следующего кадра.*/

    world.draw(); /*Отрисовываем игровой мир на основе подготовленных данных.*/
    player.draw(); /*Отрисовываем игрока на основе подготовленных данных.*/

    window.setTimeout('tick()', 1000 / 60);
};

tick();